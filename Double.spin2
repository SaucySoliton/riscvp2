{{
        Double -- double (and single) precision floating point routines for
	the Propeller

        Copyright (c) 2012-2019 Total Spectrum Software Inc.

        Released under the MIT License (see the end of this file for details)      
}}

'#define DEBUG

CON
  FLAG_SIGN      = $1
  FLAG_ZERO      = $2
  FLAG_INF	 = $4
  FLAG_NAN       = $8
  FLAG_STICKY	 = $10

  FBIAS_EXP	 = 127
  FMAX_EXP	 = 255

  DBIAS_EXP	 = 1023
  DMAX_EXP	 = $7ff
'' mask for double mantissa (high word)
  DMANTMASK	 = $000FFFFF
'' mask for float mantissa
  FMANTMASK   	 = $007FFFFF

  one_4_28	 = $1000_0000
  NAN_32	 = $7fc0_0000
  
DAT

'----------------------------
' Assembly language routines
'----------------------------

'----------------------------
' Main control loop
'----------------------------

#define r0	x10
#define	r1	x11
#define	r2	x12
#define	r3	x13

		org     $1d0

A		res	1
Alo		res	1
Aflag		res	1
Aexp		res	1

B		res	1
Blo		res	1
Bflag		res	1
Bexp		res	1

C		res	1
Clo		res	1
Cflag		res	1
Cexp		res	1

tmp0		res	1
tmp1		res	1
tmp2		res	1

Alo2		res	1
count		res	1
Btmp		res	1


		fit	$1f0

		orgh

		''
		'' code to unpack a double in A, Alo
		'' the IEEE format is 1 bit sign, 11 bit exponent,
		'' then 52 bit mantissa
		''
DUnpack
		mov	Aflag, #0
		mov	Aexp, A
		shl	Aexp, #1 wc
	if_c	or	Aflag, #FLAG_SIGN
		and	A, ##DMANTMASK	' mask off exponent and sign bit
		shr	Aexp, #21 wz	' extract exponent
	if_z	jmp	#_Ddenorm	' zero or denormal
		cmp	Aexp, ##DMAX_EXP wz
		sub	Aexp, ##DBIAS_EXP  ' remove bias
	if_z	jmp	#_Dnan	      	' NaN or Infinity

		'' now shift up to 4.28 to give head room
		'' we start with 1.20
		mov	tmp0, Alo
		shl	A, #8
		shl	Alo, #8
		shr	tmp0, #24
		or	A, tmp0
		or	A, ##one_4_28	'' or in implied one
DUnpack_ret
		ret

		'' normalize a denormalized number
_Ddenorm
		sub	Aexp, ##DBIAS_EXP
		'' adjust for converting from 1.52 to 1.60
		add	Aexp, #(1+8)
		'' check for all 0
		mov	 pa, A
		or 	 pa, Alo wz
	if_z	sub	 Aexp, #64
	if_z	or	 Aflag, #FLAG_ZERO
	if_z	ret
		'' not all 0, renormalize
		jmp    #Normalize

		'' handle NaN or Infinity
_Dnan
		mov	Aexp, ##DMAX_EXP
		mov	pa, A
		or	pa, Alo wz	'' check for infinity
	if_z	or	Aflag, #FLAG_INF
	if_z	mov	A, ##one_4_28
	if_nz	or	Aflag, #FLAG_NAN
	if_nz	add	Aexp, Aexp
		ret

		''
		'' code to unpack a single precision float in A
		'' the IEEE format is 1 bit sign, 8 bit exponent,
		'' then 23 bit mantissa
		''
FUnpack
		mov	Alo, #0
		mov	Aflag, #0
		mov	Aexp, A
		shl	Aexp, #1 wc
	if_c	or	Aflag, #FLAG_SIGN
		and	A, ##FMANTMASK	' mask off exponent and sign bit
		shr	Aexp, #24 wz	' extract exponent
	if_z	jmp	#_Fdenorm	' zero or denormal
		cmp	Aexp, #FMAX_EXP wz
		sub	Aexp, #FBIAS_EXP  ' remove bias
	if_z	jmp	#_Fnan	      	' NaN or Infinity

		'' now shift up to 4.28 to give head room
		'' we start with 1.23
		shl	A, #5
		or	A, ##one_4_28	'' or in implied one
		ret

		'' handle NaN or Infinity
_Fnan
		mov	Aexp, #FMAX_EXP
		mov	pa, A
		or	pa, Alo wz
	if_z	or	Aflag, #FLAG_INF
	if_z	mov	A, ##one_4_28
	if_nz	or	Aflag, #FLAG_NAN
	if_nz	add	Aexp, Aexp
		ret

		'' normalize a denormalized number
_Fdenorm
		sub	Aexp, #(FBIAS_EXP-1)
		'' adjust for converting from 1.23 to 1.28
		'' and check for all 0
		shl	  A, #5 wz
	if_z	sub	 Aexp, #511
	if_z	or	 Aflag, #FLAG_ZERO
	if_z	ret
		'' not all 0, renormalize
		jmp   #Normalize


		''
		'' re-normalize A to 4.28 format
		''
Normalize
		'' check for 0
		mov	pa, A
		or	pa, Alo wz
	if_z	or	Aflag, #FLAG_ZERO
	if_z	ret

		'' shift down if necessary
_down
		test	A, ##$E000_0000 wz
	if_z	jmp	#_up
		add	Aexp, #1
		shr	A, #1 wc
		rcr	Alo, #1 wc
	if_c	or	Aflag, #FLAG_STICKY	' remember we lost bits

		jmp	#_down

_up
		test   A, ##one_4_28 wz
	if_nz	ret

		shl    Alo, #1 wc
		rcl    A, #1
		sub    Aexp, #1
		jmp    #_up
Normalize_ret
		ret

		''
		'' pack a 4.60 number in A,Alo back to an IEEE double
		'' in r1,r0
		''
		'' need to handle rounding and such!
		''
		'' input is assumed to be normalized
		''
DPack
#ifdef DEBUG
		mov	uart_char, #"m"
		call	#ser_tx
#endif		
		test	Aflag, #(FLAG_INF|FLAG_NAN|FLAG_ZERO) wz
	if_nz	jmp	#dpack_excep

#ifdef DEBUG
		mov	uart_char, #"n"
		call	#ser_tx
#endif		
		call	#Normalize
		'' fix up exponent
		add	Aexp, ##DBIAS_EXP
		fles	Aexp, ##DMAX_EXP-1 wc
	if_c	mov	A, #0
	if_c	or	Aflag, #(FLAG_INF)
	if_c	jmp	#dpack_excep
		cmps	Aexp, #0 wcz
	if_be	call	#dpack_denorm

		'' round here
		'' we clear the implied one first, and allow the
		'' rounding to propagate up to it
		andn	A, ##one_4_28
		test	Aflag, #FLAG_STICKY wz

		'' we have 4.60, we want to round to 4.52
		'' half of the lsb is therefore 0x80
		'' we also want to round to nearest even, so
		'' add a sticky bit if the lsb is set
		test    Alo, #$100 wc
    if_nz_or_c	or	Alo, #1
		add	Alo, #$7f wc
		addx  	A, #0

dpack_exp
#ifdef DEBUG
		mov	uart_char, #"s"
		call	#ser_tx
#endif		
		'' now shift down to 12.52
		shr     Alo,#8
		mov     tmp0,A
		shr     A,#8
		shl     tmp0,#24
		or      Alo,tmp0

		shl	Aexp, #20

		mov	r0, Alo
		mov	r1, A
		add	r1, Aexp

		shl	Aflag, #31
		or	r1, Aflag
DPack_ret
#ifdef DEBUG
		mov	uart_char, #"z"
		call	#ser_tx
#endif		
		ret

		''
		'' exponent is <=0, so we have to create an IEEE denormalized
		'' number
dpack_denorm

		abs	Aexp, Aexp
		add	Aexp, #1
_ddlp
		shr	A, #1 wc
		rcr	Alo, #1 wc
	if_c	or	Aflag, #FLAG_STICKY
		djnz	Aexp, #_ddlp

		ret
dpack_excep
#ifdef DEBUG
		mov	uart_char, #"p"
		call	#ser_tx
#endif		
		mov	A, #0
		mov	Alo, #0
		mov	Aexp, ##DMAX_EXP
		test	Aflag, #FLAG_NAN wz
	if_nz	mov	A, ##one_4_28
	if_nz	shr	A, #1
	if_nz	jmp	#dpack_exp
#ifdef DEBUG
		mov	uart_char, #"t"
		call	#ser_tx
#endif		
		test	Aflag, #FLAG_ZERO wz
	if_nz	mov	Aexp, #0
		jmp	#dpack_exp

		''
		'' unpack (r1,r0) into A and (r3,r2) into B
		''
DUnpack2
		mov	A,r3
		mov	Alo,r2
		call	#DUnpack
		mov	B,A
		mov	Blo,Alo
		mov	Bflag,Aflag
		mov	Bexp,Aexp
		mov	A,r1
		mov	Alo,r0
		jmp	#DUnpack


		''
		'' pack a 4.60 number in A back to an IEEE float
		'' in r0
		''
		'' need to handle rounding and such!
		''
		'' input is assumed to be normalized
		''
FPack
		call	#Normalize
		test	Aflag, #(FLAG_INF|FLAG_NAN|FLAG_ZERO) wz
	if_nz	jmp	#fpack_excep

		'' fix up exponent
		add	Aexp, #FBIAS_EXP
		fles	Aexp, #FMAX_EXP-1 wc
	if_c	or	Aflag, #FLAG_INF
	if_c	jmp	#fpack_excep
		cmps	Aexp, #0 wcz
	if_be	call	#fpack_denorm

		'' round here
		'' we clear the implied one first, and allow the
		'' rounding to propagate up to it
		andn	A, ##one_4_28
		cmp	Alo,#0 wz
	if_nz	or	Aflag, #FLAG_STICKY
		test	Aflag, #FLAG_STICKY wz
		'' we have 4.28, we want to round to 4.23
		'' half of the lsb is therefore 0x10
		'' we also round to nearest even, so add a sticky
		'' bit if lsb is set
		test	A, #$20 wc
    if_nz_or_c	or	A, #1

		add	A, #$f

fpack_exp
		'' now shift down to 9.23
		shr     A,#5 wz
		shl	Aexp, #23

		mov	r0, A
		add	r0, Aexp

		shl	Aflag, #31
		or	r0, Aflag
		ret

		''
		'' exponent is <=0, so we have to create an IEEE denormalized
		'' number
fpack_denorm
		abs	Aexp, Aexp
		add	Aexp, #1	' shift one extra space
_fdlp
		shr	A, #1 wcz
	if_c	or	Aflag, #FLAG_STICKY
	if_z	mov	Aexp, #0
	if_nz	djnz	Aexp, #_fdlp

fpack_denorm_ret
		ret
fpack_excep
		mov	A, #0
		mov	Aexp, #FMAX_EXP

		test	Aflag, #FLAG_NAN wz
	if_nz	mov	r0, ##NAN_32
	if_nz	ret
		test	Aflag, #FLAG_ZERO wz
	if_nz	mov	r0, #0
	if_nz	ret
		jmp	#fpack_exp

		''
		'' unpack 2 floats in r0,r1 into A,B
		''
FUnpack2
		mov	A, r1
		call	#FUnpack
		mov	Blo,Alo
		mov	B, A
		mov	Bflag,Aflag
		mov	Bexp,Aexp
		mov	A, r0
		jmp	#FUnpack


'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'' Actual commands start here
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

		'' addition and subtraction
DSub
		xor	r3, ##$80000000
		'' fall through

DAdd
		call	#DUnpack2
		call	#_Add
		jmp	#DPack
		

DMul
		call	#DUnpack2
		call	#_Mul
		jmp	#DPack

DDiv
		call	#DUnpack2
		call	#_Div
		jmp	#DPack

DSqrt
#ifdef DEBUG
		mov	uart_char, #"&"
		call	#ser_tx
		pop	uart_num
		push	uart_num
		call	#ser_hex
#endif		
		mov	A, r1
		mov	Alo, r0
		call	#DUnpack
		call	#_Sqrt
		call	#DPack
#ifdef DEBUG
		mov	uart_char, #"*"
		call	#ser_tx
		pop	uart_num
		push	uart_num
		call	#ser_hex
#endif		
		ret
		
	'' single precision operations
FSub
		xor	r1, ##$80000000
		'' fall through

FAdd
		call	#FUnpack2
		call	#_Add
		jmp	#FPack

FMul
		call	#FUnpack2
		call	#_Mul
		jmp	#FPack

FDiv
		call	#FUnpack2
		call	#_DivSmall
		jmp	#FPack

FSqrt
		mov	A, r0
		call	#FUnpack
		call	#_Sqrt
		jmp	#FPack
		
	'' conversion operations
	'' single to double
FToD
		mov	A, r0
		call	#FUnpack
		jmp	#DPack

	'' double to single
DToF
		mov	A, r1
		mov	Alo, r0
		call	#DUnpack
		jmp	#FPack

	'' 32 bit signed integer to float
IToF
		abs	A, r0 wc, wz
		mov	Aflag, #0
	if_c	or	Aflag, #FLAG_SIGN
		mov	r2, #0		'' single precision

doint
	if_z	mov	r1, #0
	if_z	ret			'' 0 -> 0
		mov	Alo, #0
		mov	Aexp,#28	'' set the exponent
		cmp	r2, #0 wz
	if_nz	jmp	#dblprec
		jmp	#FPack

dblprec
		jmp	#DPack

	'' 32 bit unsigned integer to float
UIToF
		mov	A, r0 wz,wc
		mov	Aflag, #0
		mov	r2, #0		'' single precision
		jmp	#doint

	'' 32 bit signed integer to double
IToD
		abs	A, r0 wc, wz
		mov	Aflag, #0
	if_c	or	Aflag, #FLAG_SIGN
		mov	r2, #1		'' double precision
		jmp	#doint
	'' 32 bit unsigned integer to double
UIToD
		mov	A, r0 wz
		mov	Aflag, #0
		mov	r2, #1		'' double precision
		jmp	#doint


'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'' Utility functions go here
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

		''
		'' the actual add routine
		''
_Add
		'' swap so magnitude of A is bigger than that of B
		'' NOTE: we are assuming here that infinity is given
		'' a big Aexp, and 0 a very tiny one
		cmps	Aexp, Bexp wcz
	if_a	jmp  	#_addnoswap
	if_b	jmp	#_addswap
		cmp	Alo,Blo wz,wc
		cmpx	A,B	wz,wc
	if_ae	jmp	#_addnoswap
_addswap
		mov	tmp0,Aflag
		mov	tmp1,Aexp
		mov	Aflag,Bflag
		mov	Aexp, Bexp
		mov	Bflag,tmp0
		mov	Bexp, tmp1
		mov	tmp0, A
		mov	tmp1, Alo
		mov	A, B
		mov	Alo, Blo
		mov	B, tmp0
		mov	Blo, tmp1

_addnoswap
		'' shift B down as necessary
		'' if we are shifting more than 63 then
		'' we just return the original value

		mov	tmp0,Aexp
		sub	tmp0,Bexp wz
	if_z	jmp	#_doadd
		fle	tmp0,#63 wc
		'' FIXME: should raise inexact here?
	if_c	ret

		'' check for short shift
		cmp	tmp0,#32 wcz
	if_b	jmp	#_addshift

		'' shifting B by more than 32
		cmp	Blo,#0   wz
	if_nz	or	Aflag, #FLAG_STICKY
		mov	Blo, B
		mov	B, #0
		sub	tmp0,#32 wz
_addshift
		'' now shift B, Blo by tmp0 which is < 32
		'' (B,Blo) >> tmp0 = (B>>tmp0),  (B<<tmp1)|(Blo>>tmp0)
		mov	 tmp1,#32
		sub	 tmp1,tmp0
		mov	 Btmp,Blo
		shl	 Btmp,tmp1 wz
	if_nz	or	 Aflag, #FLAG_STICKY
		shr	 Blo, tmp0
		mov	 Btmp, B
		shr	 B, tmp0
		shl	 Btmp, tmp1
		or	 Blo, Btmp
_doadd
		'' now perform the addition
		mov	tmp0, Aflag
		xor     tmp0, Bflag
		test    tmp0, #FLAG_SIGN wz
	if_nz	jmp     #_dosub
		add     Alo, Blo wc
		addx    A, B
		ret
_dosub
		'' check for INF - INF
		'' note that if B is INF, then A is NAN or INF, so
		'' in either case NAN is appropriate to return
		test	Bflag, #FLAG_INF wz
	if_nz	or	Aflag, #FLAG_NAN
		test	Aflag, #FLAG_STICKY wc
		subx	Alo, Blo wcz
		subx	A, B
		mov	Blo, Alo
		or	Blo, A wz
	if_z	andn	Aflag, #FLAG_SIGN
	if_z	or	Aflag, #FLAG_ZERO
		ret

		'' the actual multiply routine
_Mul
		mov	tmp0,Aflag
		or	tmp0,Bflag
		test	tmp0,#(FLAG_INF|FLAG_NAN) wz
	if_nz	jmp	#_mul_excep
		'' regular multiply
		add	Aexp,Bexp
		
		'' calculate (A,Alo) * (B, Blo)
		'' both are 4.60 numbers
#ifdef DEBUG
		mov	tmp2, ##@debugptr
		wrlong	A, tmp2
		add	tmp2, #4
		wrlong	Alo, tmp2
		add	tmp2, #4
		wrlong	B, tmp2
		add	tmp2, #4
		wrlong	Blo, tmp2
#endif		
		'' (A * B) + (A * Blo) >> 32 + (B * Alo) >> 32 + (Alo * Blo) >> 64
		'' we build up the result in:
		'' A, Alo, Alo2, tmp1
		mov	tmp1, #0
		mov	tmp2, #0
		cmp	Blo, #0 wz
	if_nz	qmul	Alo, Blo
	if_nz	getqx	tmp1
	if_nz	getqy	tmp2	'' need to add tmp2 to Alo
		cmp	tmp1, #0 wz
	if_nz	or	Aflag, #FLAG_STICKY
	
		'' (Alo, Alo2) = B * Alo
		mov	Alo2, #0
		cmp	Alo, #0 wz
	if_nz	qmul	B, Alo
	if_nz	getqx	Alo2
	if_nz	getqy	Alo

		'' (tmp0,tmp1) = A * Blo
		mov	tmp1, #0
		mov	tmp0, #0
		cmp	Blo, #0 wz
	if_nz	qmul	A, Blo
	if_nz	getqx	tmp1
	if_nz	getqy	tmp0

		qmul	A, B
		'' OK, main multiply is in flight so we're done with A, Alo, etc
		'' currently we have:
		''  0, Alo, Alo2
		''     tmp0, tmp1
		''     0,    tmp2, 0
		''
		mov	A, #0
		
		add	Alo2, tmp1 wc
		addx	Alo, tmp0 wc
		addx	A, #0

		add	Alo2, tmp2 wc
		addx	Alo, #0 wc
		addx	A, #0

		getqx	tmp1
		getqy	tmp0
		add	Alo, tmp1 wc
		addx	A, tmp0

		'' now shift up 4 to convert
		'' 8.120 to 4.124
		mov	tmp0, Alo
		mov	tmp1, Alo2
		shr	tmp0, #28
		shr	tmp1, #28
		shl	A, #4
		or	A, tmp0
		shl	Alo, #4
		or	Alo, tmp1
		shl	Alo2, #4 wz
	if_nz	or	Aflag, #FLAG_STICKY
#ifdef DEBUG
		mov	tmp1, ##@debugptr+12
		wrlong	A, tmp1
		add	tmp1, #4
		wrlong	Alo, tmp1
		add	tmp1, #4
		wrlong	Alo2, tmp1
#endif		
_mul_sign
		mov	tmp0,Aflag
		xor	tmp0,Bflag
		test	tmp0,#FLAG_SIGN wz
		muxnz	Aflag,#FLAG_SIGN
_Mul_ret
		ret

		'' special cases for inf, NaN
_mul_excep
		'' if we get here, we know that either the
		'' NAN or INF bit is set
		'' if 0 is set as well, we have an illegal condition
		'' NAN*anything = NAN
		'' 0*inf == NAN
		test	tmp0, #(FLAG_NAN|FLAG_ZERO) wz
	if_nz	or	Aflag,#FLAG_NAN
	if_z	or	Aflag,#FLAG_INF
		jmp	#_mul_sign

		''
		'' the actual division routine
		''
		''
		'' (A, Alo) / (B, Blo)
		''
		'' DivSmall is for when Alo and Blo are both 0
		''
_DivSmall
		'' start div, assuming we will need it
		shr	A, #4 	       ' bottom bits of A are 0
		qfrac	A, B

		'' set sign of result
		mov    tmp0, Aflag
		xor    tmp0, Bflag
		test   tmp0, #FLAG_SIGN wz
		muxnz  Aflag, #FLAG_SIGN
		
		mov	tmp0, Aflag
		or	tmp0, Bflag
		'' check for divide by infinity or NAN
		test	tmp0, #(FLAG_INF|FLAG_NAN) wz
	if_nz	jmp	#_div_excep
		'' check for divide by 0
		test	Bflag, #FLAG_ZERO wz
	if_nz	jmp	#_div_by_zero

		sub	Aexp, Bexp
		getqx	A       ' quotient
		getqy	tmp0	' remainder
		cmp	tmp0, #0 wz
	if_nz	or	Aflag, #FLAG_STICKY
		ret

		''
		'' perform 4.60 / 4.60 division
		''
_Div
		mov	count,#61
_doDiv
		'' set the sign of the result
		mov	tmp0, Aflag
		xor	tmp0, Bflag
		test	tmp0, #FLAG_SIGN wz
		muxnz	Aflag,#FLAG_SIGN

		mov	tmp0, Aflag
		or	tmp0, Bflag
		'' check for divide by infinity or NAN
		test	tmp0, #(FLAG_INF|FLAG_NAN) wz
	if_nz	jmp	#_div_excep
		'' check for divide by 0
		test	Bflag, #FLAG_ZERO wz
	if_nz	jmp	#_div_by_zero

		'' regular divide loop here
		sub	Aexp, Bexp
		mov	tmp0, Alo
		mov	tmp1, A
		'' initialize quotient
		mov	A, #0
		mov	Alo, #0
_divloop
		cmp	tmp0, Blo wcz
		cmpx	tmp1, B wcz
	if_b	jmp	#_div_skip_sub
		sub	tmp0, Blo wcz
		subx	tmp1, B
		shl	Alo, #1 wc
		or	Alo, #1
		jmp	#_div_next
_div_skip_sub
		shl	Alo, #1 wc
_div_next
		rcl	A, #1
		shl	tmp0, #1 wc
		rcl	tmp1, #1
		djnz	count, #_divloop

		'' set sticky bit if necessary
		or     	 tmp0,tmp1 wz
	if_nz	or	 Aflag, #FLAG_STICKY

_Div_ret
_DivSmall_ret
		ret

_div_by_zero
		test	Aflag, #(FLAG_NAN|FLAG_INF|FLAG_ZERO) wz
	if_nz	or	Aflag, #FLAG_NAN
	if_z	or	Aflag, #FLAG_INF
		jmp	#_Div_ret

		''
		'' if some number is infinity or NaN, come here
		''
_div_excep
		test	tmp0, #FLAG_NAN wz
_div_nan
	if_nz	or	Aflag, #FLAG_NAN
	if_nz	jmp	#_Div_ret

		test	Aflag, #FLAG_INF wz
	if_z	jmp	#_a_finite
		'' infinity/x
		test	Bflag, #(FLAG_INF) wz
	if_nz	jmp	#_div_nan
		jmp	#_Div_ret

		'' x/infinity
_a_finite
		or	Aflag, #FLAG_ZERO
		mov	A, #0
		mov	Alo, #0
		jmp	#_Div_ret

		''
		'' square root calculation
		''
_Sqrt
#ifdef DEBUG
		mov	uart_char, #"$"
		call	#ser_tx
		mov	uart_num, Aflag
		call	#ser_hex
		mov	uart_num, A
		call	#ser_hex
		mov	uart_num, Alo
		call	#ser_hex
#endif		
		test	Aflag, #(FLAG_INF|FLAG_NAN|FLAG_ZERO) wz
	if_nz	ret
		'' sqrt(-x) -> NaN
		test	Aflag, #(FLAG_SIGN) wz
	if_nz	jmp	#sqrt_excep
	
		'' save original value of A
		mov	Cexp, Aexp
		mov	C, A
		mov	Clo, Alo
		mov	Cflag, Aflag

		test	Aexp, #1 wz	' make Aexp even if necessary
	if_nz	add	Aexp, #1
	if_nz	shr	A, #1 wc
	if_nz	rcr	Alo, #1

		'' get square root
		sar	Aexp, #1
		qsqrt	Alo, A
		getqx	A	' A has square root in 2.30 format
		
#ifdef DEBUG
		mov	uart_char, #"^"
		call	#ser_tx
		mov	uart_num, A
		call	#ser_hex
		mov	uart_num, Alo
		call	#ser_hex
#endif		
		cmp	Clo, #0 wz
	if_nz	jmp	#sqrt_heron
		cmps	Cexp, ##-FBIAS_EXP wcz
	if_be	jmp	#sqrt_heron

		'' convert to 4.28
		mov	Alo, A wz
		shl	Alo, #30
		shr	A, #2

		'' FIXME: should check here for exact squares,
		'' for which FLAG_STICKY is not appropriate
		or	Aflag, #FLAG_STICKY
#ifdef DEBUG
		mov	uart_char, #"<"
		jmp	#ser_tx
#endif		
		ret


sqrt_heron
		'' original value was X * 2^e, 0.5 <= X < 4
		'' at this point we have an approximation of y = sqrt(X)
		'' in A, as a 2.30 fixed point number 0.5 <= A < 2
		'' The original X is in C, Clo
		'' we can improve our approximation using Heron's
		'' formula:
		''   y' = 1/2 * (y + X / y)
		''
#ifdef DEBUG
		mov	uart_char, #"v"
		call	#ser_tx
#endif
		'' save original 2.30 estimate in B
		mov	B, A

		'' divide X by y giving a 4.60 bit result
		'' the actual calculation is:
		''    X = 2^-28 * C + 2^-60 * Clo
		''    y = 2^-30 * B
		'' so
		''   X / y = 2^-2 * (C / B) + (2^-30) * Clo / B
		''
		''  thus 2^60 * X / y is:
		''    2^58 * (C / B) + 2^30 * (Clo / B)
		''
		qfrac	C, B
		getqx	A	' A * B + tmp1 =  2^32 * C
		getqy	tmp1

		qfrac	tmp1, B
		getqx	Alo
		getqy	tmp2	' Alo * B + tmp2 = 2^32 * tmp1

		' so: 
		' 2^32 * C = A * B + (Alo * B + tmp2) / 2^32
		' (2^32 * C) / B = A + Alo / 2^32 + tmp2 / (2^32*B)
		' 2^58 * (C/B) = 2^26 * (A + Alo / 2^32 + remainder
		'              = (2^26 * A) + (Alo / 2^6) + remainder
		'              = 2^32 * (A >> 6) + (Alo >> 6) + remainder

		' for now, just remember that we need to shift A down by 6

		' now (A, Alo) = (2^58 * (C / B)) << 6
		' calculate 2^30 * Clo / B
		'
		qfrac	Clo, B
		getqx	tmp0
		getqy	tmp1	' tmp0 * B + tmp1 = 2^32 * Clo
	
		' 2^32 * Clo / B = (tmp0 + tmp1 / B)
		' 2^36 * Clo / B = (tmp0 << 4) + (tmp1 << 4) / B
		mov    tmp2, tmp1
		shl    tmp1, #4
		shr    tmp2, #28
		setq   tmp2
		qdiv   tmp1, B
		getqx  tmp2	' tmp2 = (tmp1 << 4) / B

		mov    tmp1, tmp0
		shr    tmp0, #28
		shl    tmp1, #4
		add    tmp1, tmp2 wc
		addx   tmp0, #0

		'' OK, here (tmp0, tmp1) + (A, Alo) should be what we need
		add	Alo, tmp1 wc
		addx    A, tmp0 wc

		' we may have overflowed, shift right
		rcr	A, #1 wc
		rcr	Alo, #1

		'' now shift (A, Alo) right by 5
		'' and divide by 2 (so total shift is 6)
		'' or, just handle it in the normalization later
#ifdef NEVER		
		mov	tmp0, A
		shl	tmp0, #26
		shr	A, #6
		shr	Alo, #6
		or	Alo, tmp0
#else
		sub	Aexp, #6
#endif		
		' FIXME: this is just a guess, but it's a good one;
		' very few 56 bit numbers are perfect squares
		or     Aflag, #FLAG_STICKY

sqrt_excep
		mov	A, #0
		mov	Alo, #0
	_ret_	or	Aflag, #FLAG_NAN
		
{{


+------------------------------------------------------------------------------------------------------------------------------+
|                                                   TERMS OF USE: MIT License                                                  |                                                            
+------------------------------------------------------------------------------------------------------------------------------+
|Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation    | 
|files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy,    |
|modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software|
|is furnished to do so, subject to the following conditions:                                                                   |
|                                                                                                                              |
|The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.|
|                                                                                                                              |
|THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE          |
|WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR         |
|COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,   |
|ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.                         |
+------------------------------------------------------------------------------------------------------------------------------+
}}
